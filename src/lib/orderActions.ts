// CLIENT-SIDE ACTION - Use the same client as AuthProvider for consistent auth state
import { getSupabaseClient } from '@/lib/supabase-client';

export async function performCheckout(
  userId: string,
  items: {
    id: string;
    quantity: number;
    price?: number; // Optional price for customized items
    name?: string; // Optional name for logging
    customization?: Record<string, unknown>; // Optional customization data - using proper typing
  }[],
  total: number,
  _deliveryType: string, // Not used in current schema but kept for API compatibility
  _email: string,
  _userDetails?: {
    firstName?: string;
    lastName?: string;
    phone?: string;
    address?: string;
  }
) {
  try {
    console.log('ðŸ”„ Starting checkout process for user:', userId);
    
    // Create the same client instance as AuthProvider to ensure consistent auth state
    const supabase = getSupabaseClient();
    
    // Verify user authentication and session
    const {
      data: { user },
      error: authError,
    } = await supabase.auth.getUser();

    // Get session separately
    const { data: { session } } = await supabase.auth.getSession();

    console.log('ðŸ” Auth check result:', {
      user: user ? { id: user.id, email: user.email } : null,
      session: session ? 'present' : 'missing',
      authError: authError?.message,
      expectedUserId: userId
    });

    if (authError) {
      console.error('âŒ Auth error:', authError);
      throw new Error(`Authentication error: ${authError.message}`);
    }

    if (!user) {
      console.error('âŒ No user found in session');
      throw new Error('Authentication error: Auth session missing!');
    }

    if (user.id !== userId) {
      console.error('âŒ User ID mismatch:', { sessionUserId: user.id, expectedUserId: userId });
      throw new Error(
        `Authentication mismatch: Please ensure you are logged in correctly`
      );
    }

    console.log('âœ… Authentication verified for user:', user.id);

    // Separate regular items from customized items based on customization field presence
    // Regular menu items: Have no customization or isCustomized=false
    // Customized items: Have customization data and/or isCustomized=true
    const regularItems = items.filter((item) => !item.customization || !item.customization.isCustomized);
    const customizedItems = items.filter((item) => item.customization && item.customization.isCustomized);

    console.log('ðŸ“ Creating draft order (order number will be auto-generated)');

    // Create order as DRAFT status (NOT visible to kitchen until payment)
    const { data: orderRecord, error: orderError } = await supabase
      .from('orders')
      .insert({
        user_id: userId,
        total_amount: total,
        status: 'draft', // DRAFT status - not visible to kitchen until payment confirmed
        payment_status: 'awaiting_payment',
        // order_number will be auto-generated by database trigger
        created_at: new Date().toISOString(),
      })
      .select('id, order_number')
      .single();

    if (orderError) throw orderError;

    const orderId = orderRecord.id;

    // Check availability only for regular menu items (not customized)
    for (const item of regularItems) {
      // Fetch current availability for the menu item
      const { data: menuItem, error: availabilityError } = await supabase
        .from('menu_items')
        .select('is_available, name')
        .eq('id', item.id)
        .single();

      if (availabilityError) {
        throw new Error(`Failed to check availability for item ${item.id}: ${availabilityError.message}`);
      }

      if (!menuItem) {
        throw new Error(`Menu item with ID ${item.id} not found in database`);
      }

      // Check if item is available
      if (!menuItem.is_available) {
        throw new Error(
          `${menuItem.name} is currently unavailable`
        );
      }
    }

    // Create order items for both regular and customized items
    const orderItems = [];

    // Process regular menu items
    for (const item of regularItems) {
      // Fetch the menu item to get the price
      const { data: menuItem, error: priceError } = await supabase
        .from('menu_items')
        .select('price, name')
        .eq('id', item.id)
        .single();

      if (priceError || !menuItem) {
        throw new Error(
          `Menu item with ID ${item.id} not found when fetching price`
        );
      }

      const unitPrice = parseFloat(menuItem.price.toString());

      orderItems.push({
        order_id: orderId,
        menu_item_id: item.id,
        quantity: item.quantity,
        price: unitPrice,
      });
    }

    // Process customized items (pizzas, etc.) - these don't have menu_item_id
    for (const item of customizedItems) {
      // Get the item price from the cart item itself
      const unitPrice = item.price ? parseFloat(item.price.toString()) : 0;

      orderItems.push({
        order_id: orderId,
        menu_item_id: null, // Customized items don't reference a menu item
        quantity: item.quantity,
        price: unitPrice,
        special_instructions: JSON.stringify({
          type: 'customized',
          customized_id: item.id,
          name: item.name || 'Custom Item',
          customization_details: item.customization || {},
        }),
      });
    }

    if (orderItems.length > 0) {
      const { error: itemsError } = await supabase
        .from('order_items')
        .insert(orderItems);
      if (itemsError) throw itemsError;
    }

    // Don't send confirmation email yet - wait for payment confirmation
    // Email will be sent from PayFast notification handler

    return { success: true, orderId };
  } catch (err: unknown) {
    console.error('Checkout error:', err);

    // Better error logging with full details
    if (err && typeof err === 'object' && 'message' in err) {
      console.error('Database error details:', {
        message: err.message,
        code: (err as Record<string, unknown>).code,
        details: (err as Record<string, unknown>).details,
        hint: (err as Record<string, unknown>).hint,
        full_error: err,
      });
    }

    console.error('Error details:', {
      name: err instanceof Error ? err.name : 'Unknown',
      message: err instanceof Error ? err.message : String(err),
      stack: err instanceof Error ? err.stack : 'No stack trace',
    });

    // Return more specific error information
    let errorMessage = 'Unknown error';
    if (err && typeof err === 'object' && 'message' in err) {
      errorMessage = String((err as Record<string, unknown>).message);
    } else if (err instanceof Error) {
      errorMessage = err.message;
    } else if (typeof err === 'string') {
      errorMessage = err;
    }

    return { success: false, error: errorMessage };
  }
}

// New function to handle payment confirmation with stock management
export async function confirmPaymentAndDecrementStock(orderId: string) {
  try {
    // Use the same client instance as AuthProvider for consistency
    const supabase = getSupabaseClient();
    
    // Update order status to confirmed and payment status to completed
    const { error: updateError } = await supabase
      .from('orders')
      .update({ 
        status: 'confirmed',
        payment_status: 'completed',
        updated_at: new Date().toISOString()
      })
      .eq('id', orderId);

    if (updateError) {
      throw updateError;
    }

    // Note: Stock management would be implemented here if we had inventory table
    // For now, just confirm payment
    return { success: true };
  } catch (err: unknown) {
    console.error('Payment confirmation error:', err);
    return {
      success: false,
      error: err instanceof Error ? err.message : 'Unknown error',
    };
  }
}

// New function to handle payment confirmation 
export async function confirmPaymentAndUpdateStatus(orderId: string) {
  try {
    // Use the same client instance as AuthProvider for consistency
    const supabase = getSupabaseClient();
    
    // Update order status to confirmed and payment status to completed
    const { error: updateError } = await supabase
      .from('orders')
      .update({ 
        status: 'confirmed',
        payment_status: 'completed',
        updated_at: new Date().toISOString()
      })
      .eq('id', orderId);

    if (updateError) {
      throw updateError;
    }

    return { success: true };
  } catch (err: unknown) {
    console.error('Payment confirmation error:', err);
    return {
      success: false,
      error: err instanceof Error ? err.message : 'Unknown error',
    };
  }
}
